package midas
package passes

import java.io.{File, FileWriter, Writer}

case class MemConf(
  name: String, 
  depth: BigInt,
  width: BigInt,
  readers: Seq[String],
  writers: Seq[String],
  readwriters: Seq[String],
  maskGran: BigInt)

object MemConfReader {
  sealed trait ConfField
  case object Name extends ConfField
  case object Depth extends ConfField
  case object Width extends ConfField
  case object Ports extends ConfField
  case object MaskGran extends ConfField
  type ConfFieldMap = Map[ConfField, String]
  // Read a conf file generated by [[firrtl.passes.ReplSeqMems]] 
  def apply(conf: java.io.File): Seq[MemConf] = {
    def parse(map: ConfFieldMap, list: List[String]): ConfFieldMap = list match {
      case Nil => map
      case "name" :: value :: tail => parse(map + (Name -> value), tail)
      case "depth" :: value :: tail => parse(map + (Depth -> value), tail)
      case "width" :: value :: tail => parse(map + (Width -> value), tail)
      case "ports" :: value :: tail => parse(map + (Ports -> value), tail)
      case "mask_gran" :: value :: tail => parse(map + (MaskGran -> value), tail)
      case field :: tail => firrtl.Utils.error(s"Unknown field $field")
    }
    io.Source.fromFile(conf).getLines.toSeq map { line =>
      val map = parse(Map[ConfField, String](), (line split " ").toList)
      val ports = map(Ports) split ","
      MemConf(map(Name), BigInt(map(Depth)), BigInt(map(Width)),
        ports filter (_ == "read"),
        ports filter (p => p == "write" || p == "mwrite"),
        ports filter (p => p == "rw" || p == "mrw"),
        map get MaskGran map (BigInt(_)) getOrElse (BigInt(0)))
    }
  }
}

object MidasMacroEmitter {
  def apply(writer: Writer)(conf: MemConf) {
    val tab = " "
    def maskWidth = (conf.width / conf.maskGran).toInt
    val addrWidth = chisel3.util.log2Up(conf.depth) max 1
    val portdefs = (conf.readers.indices flatMap (i => Seq(
      Seq(tab, "input", s"R${i}_clk"),
      Seq(tab, s"input[${addrWidth-1}:0]", s"R${i}_addr"),
      Seq(tab, "input", s"R${i}_en"),
      Seq(tab, s"output reg [${conf.width-1}:0]", s"R${i}_data"))
    )) ++ (conf.writers.zipWithIndex flatMap { case (w, i) => Seq(
      Seq(tab, "input", s"W${i}_clk"),
      Seq(tab, s"input[${addrWidth-1}:0]", s"W${i}_addr"),
      Seq(tab, "input", s"W${i}_en"),
      Seq(tab, s"input[${conf.width-1}:0]", s"W${i}_data")) ++
      (if (w.head == 'm') Seq(Seq(tab, s"input[${maskWidth-1}:0]", s"W${i}_mask")) else Nil)
    }) ++ (conf.readwriters.zipWithIndex flatMap { case (rw, i) => Seq(
      Seq(tab, "input", s"RW${i}_clk"),
      Seq(tab, s"input[${addrWidth-1}:0]", s"RW${i}_addr"),
      Seq(tab, "input", s"RW${i}_en"),
      Seq(tab, "input", s"RW${i}_wmode"),
      Seq(tab, s"input[${conf.width-1}:0]", s"RW${i}_wdata"),
      Seq(tab, s"output reg [${conf.width-1}:0]", s"RW${i}_rdata")) ++
      (if (rw.head == 'm') Seq(Seq(tab, s"input[${maskWidth-1}:0]", s"RW${i}_wmask")) else Nil)
    })
    val declares = Seq(Seq(tab, s"reg[${conf.width-1}:0] ram[${conf.depth-1}:0];")) ++
      Seq(Seq("`ifdef RANDOMIZE_MEM_INIT"),
          Seq(tab, "integer initvar;"),
          Seq(tab, "initial begin"),
          Seq(tab, tab, "#0.002;"),
          Seq(tab, tab, s"for (initvar = 0; initvar < ${conf.depth}; initvar = initvar + 1)"),
          Seq(tab, tab, tab, """/* verilator lint_off WIDTH */ ram[initvar] = {%d{$random}};""".format((conf.width - 1) / 32 + 1))) ++
      (conf.readers.indices map (i =>
          Seq(tab, tab, "/* verilator lint_off WIDTH */ R%d_data = {%d{$random}};".format(i, (addrWidth - 1) / 32 + 1)))) ++
      (conf.readwriters.indices map (i =>
          Seq(tab, tab, "/* verilator lint_off WIDTH */ RW%d_rdata = {%d{$random}};".format(i, (addrWidth - 1) / 32 + 1)))) ++
      Seq(Seq(tab, "end"),
          Seq("`endif"))
    val always = (conf.readers.indices map (i => s"R${i}_clk" ->
      Seq(Seq(tab, tab, s"if (R${i}_en)", s"R${i}_data <= ram[R${i}_addr];"))
    )) ++ (conf.writers.zipWithIndex map { case (w, i) => s"W${i}_clk" -> (
      w.head == 'm' match {
        case false => Seq(Seq(tab, tab, s"if (W${i}_en)", s"ram[W${i}_addr] <= W${i}_data;"))
        case true => (0 until maskWidth) map { k =>
          val range = s"${(k + 1) * conf.maskGran - 1} : ${k * conf.maskGran}"
          Seq(tab, tab, s"if (W${i}_en && W${i}_mask[$k])",
                        s"ram[W${i}_addr][$range] <= W${i}_data[$range];")
        }
      }
    )}) ++ (conf.readwriters.zipWithIndex map { case (w, i) => s"RW${i}_clk" -> (
      w.head == 'm' match {
        case false => Seq(
          Seq(tab, tab, s"if (RW${i}_en) begin"),
          Seq(tab, tab, tab, s"RW${i}_rdata <= ram[RW${i}_addr];"),
          Seq(tab, tab, tab, s"if (RW${i}_wmode)", s"ram[RW${i}_addr] <= RW${i}_wdata;"),
          Seq(tab, tab, "end"))
        case true => Seq(
          Seq(tab, tab, s"if (RW${i}_en) begin"),
          Seq(tab, tab, tab, s"RW${i}_rdata <= ram[RW${i}_addr];")
        ) ++ ((0 until maskWidth) map { k =>
          val range = s"${(k + 1) * conf.maskGran - 1} : ${k * conf.maskGran}"
          Seq(tab, tab, tab, s"if (RW${i}_wmode && RW${i}_wmask[${k}])",
                             s"ram[RW${i}_addr][$range] <= RW${i}_wdata[$range];")
        }) ++ Seq(
          Seq(tab, tab, "end")
        )
      }
    )})
    writer write s"""
module ${conf.name}(
%s
);
%s
%s
endmodule""".format(
     portdefs map (_ mkString " ") mkString ",\n",
     declares map (_ mkString " ") mkString "\n",
     always map { case (clk, body) => s"""
  always @(posedge $clk) begin
%s
  end""".format(body map (_ mkString " ") mkString "\n")
     } mkString "\n"
    )
  }
}

class MidasVerilogEmitter(confFile: File, macroFile: File) extends firrtl.VerilogEmitter {
  override def emit(state: firrtl.CircuitState, writer: Writer) {
    super.emit(state, writer)
    val macroWriter = new FileWriter(macroFile)
    MemConfReader(confFile) foreach MidasMacroEmitter(macroWriter)
    macroWriter.close
  }
}
