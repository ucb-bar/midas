# MIDAS Beta v0.1

MIDAS is an FPGA simulation simulation framework that automatically generates platform agnostic FPGA simulators from any RTL designs. MIDAS is an improvement over [Strober](http://dl.acm.org/citation.cfm?id=3001151) that was originally developed for sample-based energy simulation.

## Dependencies

This repo depends on the following projects:
* [Chisel](https://github.com/freechipsproject/chisel3): RTL implementations in MIDAS/Strober are written with Chisel
* [FIRRTL](https://github.com/freechipsproject/firrtl): Custom transforms in MIDAS/Strober are written with FIRRTL
* [RocketChip](https://github.com/freechipsproject/rocket-chip.git): RocketChip is not only a chip generator, but also a collection of useful libraries for various hardware designs. We take advantage of some libraries in RocketChip.
* [barstools](https://github.com/ucb-bar/barstools): Technology dependent custom transforms(e.g. macro compiler) are used for Strober.

Thie repo is not supposed to work alone. It is instantiated in top-level projects with target designs such as [strober-examples](https://github.com/donggyukim/strober-examples) and [midas-top](https://github.com/ucb-bar/midas-top.git).

## Get Started

### MIDAS Compiler

First of all, we assume the target design is written in Chisel. To generate the FPGA simulator for the target design, just pass the target design with a configuration to `MidasCompiler`:
```scala
// mod: Module (target design)
// dir: File (target directory)
// p: config.Parameters (midas configuration)
midas.MidasCompiler(mod, dir)(p)
```

If you have a JSON file describing the target technology generated by [PLSI](https://github.com/ucb-bar/hammer), pass it as:
```scala
// lib: File (technology description)
midas.MidasCompiler(mod, dir, Some(lib))(p)
```

Here are two examples in [strober-example](https://github.com/donggyukim/strober-examples/blob/master/src/main/scala/Main.scala) and [midas-top](https://github.com/ucb-bar/midas-top/blob/master/src/main/scala/Generator.scala#L161).

### MIDAS Configurations

The default MIDAS parameters are given in [src/main/scala/midas/Config.scala](https://github.com/ucb-bar/midas/blob/readme/src/main/scala/midas/Config.scala). You can just pass `ZynqConfig` to obtain performance simulation and `ZynqConfigWithSnapshot` to plug Strober in for power/energy simulation for Xilinx Zynq boards.

You may want to override some parameters on top of the default parameter values. This is an example how you can instantiate an MIDAS LLC model:
```scala
class WithMidasLLC(extends Config((site, here, up) => {
  case MidasLLCKey => Some(MidasLLCParameters(nWays = 8, nSets = 4096, blockBytes = 128)) // capacity <= 4MiB
})

class ZynqConfigWithLLC(new ZynqConfig ++ new WithMidasLLC)
```

### MIDAS Software Driver

To take control of FPGA simulation, the software driver is suppposed to be written in C++ by the users. The simplest way to write is use `peek`, `poke`, `step`, `expect` functions as in Chisel testers. The first step is write a virtual class shared by emulation and various platforms. This is a software driver for GCD (e.g. in `GCD.h`) by inheriting `simif_t` as an example:
```c++
#include "simif.h"

class GCD_t: virtual simif_t
{
public:
  void run() {
    uint32_t a = 64, b = 48, z = 16; //test vectors
    target_reset();
    do {
      poke(io_a, a);
      poke(io_b, b);
      poke(io_e, cycles() == 0 ? 1 : 0);
      step(1);
    } while (cycles() <= 1 || peek(io_v) == 0);
    expect(io_z, z);
  }
};
```

Next, to emulate and test the FPGA simulator itself, a drieved class is written (e.g. in `GCD-emul.cc`) as follow:

```c++
#include "simif_emul.h"
#include "GCD.h"

class GCD_emul_t:
  public simif_emul_t,
  public GCD_t { };

int main(int argc, char** argv)
{
  GCD_emul_t GCD;
  GCD.init(argc, argv, true);
  GCD.run();
  return GCD.finish();
}
```

For FPGA simulation in Xilinx Zynq, the code (e.g. in `GCD-zynq.cc`) is written in the same way inheriting `simif_zynq_t` instead of `simif_emul_t`:

```c++
#include "simif_zynq.h"
#include "GCD.h"

class GCD_zynq_t:
  public simif_zynq_t,
  public GCD_t { };

int main(int argc, char** argv) 
{
  GCD_zynq_t GCD;
  GCD.init(argc, argv, true);
  GCD.run();
  return GCD.finish();
}
```

In this way, we can reduce lots of code duplication for emulation and various platforms when the software driver becomes complicated.

Big numbers more than 64 bits can be defined by `mpz_t` in [GMP](https://gmplib.org/), and passed to `peek`, `poke`, `expect` functions.

To compile the driver, `make` is invoked in `src/main/cc`. Thus, the top-level makefile is likely to contain the wrapper as follows:
```makefile
compile-driver:
  $(MAKE) -C $(midas_dir)/src/main/cc [verilator | vcs | zynq] [variable="<value>"]*
```

The variables are:
* `PLATFORM`: Platform name (zynq by default)
* `DESIGN`: Target design name
* `GEN_DIR`: The directory containing generated files from MIDAS Compiler (=`dir`)
* `OUT_DIR`: The directory for output files (`GEN_DIR` by default)
* `DRIVER`: The driver files written by the user (not including header files)
* `CXXFLAGS`: additional compiler flags
